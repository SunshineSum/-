### 1.如何产生闭包？
> 1. 两个函数嵌套
> 2. 内部函数引用了外部函数的局部变量
> 3. 执行外部函数的过程中产生了闭包

 **探讨1**：执行外部函数时具体哪个阶段产生了闭包？<br>
>
> 是内部函数对象产生（也就是执行内部函数定义时）的时候，产生的闭包。
```
function fn1() {
    //执行到该行时，就产生了闭包。
    //因为fn2是使用了function关键字定义，刚执行fn1时，会存在预解析，预解析此时已经执行了fn2的定义，所以闭包产生。
    var a = 2
    function fn2() {
        a++
        console.log(a)
    }
    return fn2
    var f = fn1()
    f()
    f()
}
```


```
function fn1() {
    var a = 2
    var fn2 = function() {
        a++
        console.log(a)
    }
    //执行到该行时，产生了闭包。
    //因为fn2是使用var定义，预解析完毕fn2的值是undefined，只有执行到此处内部函数创建完成，才产生闭包。
    return fn2
    var f = fn1()
    f()
    f()
}
```
**探讨2**：闭包一定要把内部函数return出去吗？<br>
>
> 不一定，return只是让这个闭包存活下来，不return也会产生闭包，只不过外部函数执行完，内部函数的引用fn2作为一个局部变量，立刻被释放，导致之前fn2指向的函数对象，失去了引用，所以闭包立刻就消失了。<br>
>
>我们经常return内部函数对象的原因：想让这闭包“活”下来，如果不return，那么闭包在执行完外部函数就“死掉”了，没有任何意义。
```
function fn1() {
    var a = 2
    function fn2() {
        a++
        console.log(a)
    }
    return fn2
    var f = fn1()
    //执行至此fn2变量已经被释放，但他之前所指向的函数对象重新被f所引用，这样他就“活”了下来。
    f()
    f()
}
```

### 2.闭包是什么?
> 1. 包含着被引用的局部变量的容器，它被内部函数引用着。
> 2. return后，它被外部接收它的变量引用着。
### 3.闭包的作用？
> 1. 延长局部变量的生命周期
> 2. 使函数外部可以多次间接操作到函数内部的数据。
### 4.闭包的应用
> 1. 循环遍历加监听。
> 2. IIFE定义模块。
> 3. 例如Jquery内部就是一个大的闭包。

### 5. 如何“干掉”闭包？
> 让引用闭包的变量，指向null，例如上述代码，f =null